<h1 align="center">Ordenação</h1>

<h3>Bubblesort</h3>
<p>Itera n-1 vezes sobre todos os dados, comparando elementos adjacentes</p>
<p>O(n^2)</p>

<h3>SelectionSort</h3>
<p>Encontra o menor elemento do arranjo e troca-o de lugar, fazendo (n-1)/2 comparações</p>
<p>O(n^2)</p>

<h3>InsertionSort</h3>
<p>A cada passo, o vetor até j-1 é mantido ordenado e o elemento de índice j é inserido</p>
<p>Os itens são deslocados até ser encontrado um menor que o atual - a posição de inserção é encontrada</p>
<p>O(n^2)</p>

<h3>ShellSort</h3>
<p>Considera gaps decrescentes para definir a sublista de itens a serem comparados</p>
<p>O((nlgn)^2)</p>

<h3>QuickSort</h3>
<p>Paradigma de divisão e conquista: uso de um elemento pivô x, particionado o arranjo em 2 (direita de x e esquerda de x), ordenando cada partição recursivamente</p>
<p>O(nlgn)</p>

<h3>MergeSort</h3>
<p>Paradigma de divisão e conquista: o vetor de n itens é dividido em dois subvetores de n/2 itens, recursivamente ordenados</p>
<p>O(nlgn)</p>

<h3>Códigos</h3>
<p>Implementações em <a href="https://github.com/m-fidalgo/unesp/tree/master/atp-2/exs/07-ordenacao/exemplos">link</a></p>
